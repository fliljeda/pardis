Dining philosopher problem. n number of philosophers are sitting around a round table with n number of forks placed 1 by 1 between each philosopher. To eat, one philosopher apparently has to pick up both forks adjacent to him/her. We call these two forks the left and the right fork. The problem is that if you pick upp the right fork, the philospher to the right of you can't pick up his/her left fork (your right fork). If the philosophers are stubborn and won't let go of their forks, we might end up in a deadlock situation. The only way this can actually deadlock is if every philosopher picks up their fork at the 'same time' and they all pick up the same direction (right or left) fork so that all philosophers hold one fork each. This can be translated into a problem of locks and threads in CS. If all processes picks up one lock but also require a second lock which is busy waiting for another lock and it all comes in a circle, we end up with a deadlock. It is important to understand how fragile this deadlock risk is, it can only happen if all threads manage to pick up one lock in a circle depending on another in the same circle. This means that there are many solutions to the problem. The easiest one and the one we implemented is to have all philosophers choose their right side fork as their first fork EXCEPT for one philosopher which chooses the left fork first. This one philosopher that chooses the left fork first will either find that the left fork is busy and he waits for it, or another philosopher is currently eating and will eventually stop. If the left fork is busy, then it means that the one philosopher that chooses the left fork first, does not use any fork and someone around the table will be able to use their left fork. 
